//
// Generated file, do not edit! Created by nedtool 5.6 from inet/_extra/networklayer/FilterRule.msg.
//

#ifndef __INET_FILTERRULE_M_H
#define __INET_FILTERRULE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// dll export symbol
#ifndef INET_API
#  if defined(INET_EXPORT)
#    define INET_API  OPP_DLLEXPORT
#  elif defined(INET_IMPORT)
#    define INET_API  OPP_DLLIMPORT
#  else
#    define INET_API
#  endif
#endif


namespace inet {

class Ipv4Match;
class Ipv6Match;
class TcpMatch;
class UdpMatch;
class IcmpMatch;
class Matches;
class Action;
} // namespace inet

#include "inet/networklayer/contract/ipv4/Ipv4Address_m.h" // import inet.networklayer.contract.ipv4.Ipv4Address

#include "inet/networklayer/contract/ipv6/Ipv6Address_m.h" // import inet.networklayer.contract.ipv6.Ipv6Address

#include "inet/_extra/transportlayer/PortRange_m.h" // import inet._extra.transportlayer.PortRange


namespace inet {

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:41</tt> by nedtool.
 * <pre>
 * class Ipv4Match
 * {
 *     uint16_t length;
 *     uint8_t protocol;
 *     Ipv4Address destNetwork;
 *     Ipv4Address srcNetwork;
 *     uint8_t fragmentOp;
 *     uint8_t fragmentType;
 * }
 * </pre>
 */
class INET_API Ipv4Match
{
  protected:
    uint16_t length = 0;
    uint8_t protocol = 0;
    Ipv4Address destNetwork;
    Ipv4Address srcNetwork;
    uint8_t fragmentOp = 0;
    uint8_t fragmentType = 0;

  private:
    void copy(const Ipv4Match& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv4Match&);

  public:
    Ipv4Match();
    Ipv4Match(const Ipv4Match& other);
    virtual ~Ipv4Match();
    Ipv4Match& operator=(const Ipv4Match& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getLength() const;
    virtual void setLength(uint16_t length);
    virtual uint8_t getProtocol() const;
    virtual void setProtocol(uint8_t protocol);
    virtual const Ipv4Address& getDestNetwork() const;
    virtual Ipv4Address& getDestNetworkForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ipv4Match*>(this)->getDestNetwork());}
    virtual void setDestNetwork(const Ipv4Address& destNetwork);
    virtual const Ipv4Address& getSrcNetwork() const;
    virtual Ipv4Address& getSrcNetworkForUpdate() { return const_cast<Ipv4Address&>(const_cast<Ipv4Match*>(this)->getSrcNetwork());}
    virtual void setSrcNetwork(const Ipv4Address& srcNetwork);
    virtual uint8_t getFragmentOp() const;
    virtual void setFragmentOp(uint8_t fragmentOp);
    virtual uint8_t getFragmentType() const;
    virtual void setFragmentType(uint8_t fragmentType);
};

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:50</tt> by nedtool.
 * <pre>
 * class Ipv6Match
 * {
 *     uint16_t length;
 *     uint8_t protocol;
 *     Ipv6Address destNetwork;
 *     Ipv6Address srcNetwork;
 *     uint8_t fragmentOp;
 *     uint8_t fragmentType;
 * }
 * </pre>
 */
class INET_API Ipv6Match
{
  protected:
    uint16_t length = 0;
    uint8_t protocol = 0;
    Ipv6Address destNetwork;
    Ipv6Address srcNetwork;
    uint8_t fragmentOp = 0;
    uint8_t fragmentType = 0;

  private:
    void copy(const Ipv6Match& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Ipv6Match&);

  public:
    Ipv6Match();
    Ipv6Match(const Ipv6Match& other);
    virtual ~Ipv6Match();
    Ipv6Match& operator=(const Ipv6Match& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getLength() const;
    virtual void setLength(uint16_t length);
    virtual uint8_t getProtocol() const;
    virtual void setProtocol(uint8_t protocol);
    virtual const Ipv6Address& getDestNetwork() const;
    virtual Ipv6Address& getDestNetworkForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6Match*>(this)->getDestNetwork());}
    virtual void setDestNetwork(const Ipv6Address& destNetwork);
    virtual const Ipv6Address& getSrcNetwork() const;
    virtual Ipv6Address& getSrcNetworkForUpdate() { return const_cast<Ipv6Address&>(const_cast<Ipv6Match*>(this)->getSrcNetwork());}
    virtual void setSrcNetwork(const Ipv6Address& srcNetwork);
    virtual uint8_t getFragmentOp() const;
    virtual void setFragmentOp(uint8_t fragmentOp);
    virtual uint8_t getFragmentType() const;
    virtual void setFragmentType(uint8_t fragmentType);
};

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:59</tt> by nedtool.
 * <pre>
 * class TcpMatch
 * {
 *     uint8_t op;
 *     uint16_t bitmask;
 *     PortRange srcPortRange;
 *     PortRange destPortRange;
 * }
 * </pre>
 */
class INET_API TcpMatch
{
  protected:
    uint8_t op = 0;
    uint16_t bitmask = 0;
    PortRange srcPortRange;
    PortRange destPortRange;

  private:
    void copy(const TcpMatch& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const TcpMatch&);

  public:
    TcpMatch();
    TcpMatch(const TcpMatch& other);
    virtual ~TcpMatch();
    TcpMatch& operator=(const TcpMatch& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint8_t getOp() const;
    virtual void setOp(uint8_t op);
    virtual uint16_t getBitmask() const;
    virtual void setBitmask(uint16_t bitmask);
    virtual const PortRange& getSrcPortRange() const;
    virtual PortRange& getSrcPortRangeForUpdate() { return const_cast<PortRange&>(const_cast<TcpMatch*>(this)->getSrcPortRange());}
    virtual void setSrcPortRange(const PortRange& srcPortRange);
    virtual const PortRange& getDestPortRange() const;
    virtual PortRange& getDestPortRangeForUpdate() { return const_cast<PortRange&>(const_cast<TcpMatch*>(this)->getDestPortRange());}
    virtual void setDestPortRange(const PortRange& destPortRange);
};

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:66</tt> by nedtool.
 * <pre>
 * class UdpMatch
 * {
 *     uint16_t length;
 *     PortRange srcPortRange;
 *     PortRange destPortRange;
 * }
 * </pre>
 */
class INET_API UdpMatch
{
  protected:
    uint16_t length = 0;
    PortRange srcPortRange;
    PortRange destPortRange;

  private:
    void copy(const UdpMatch& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const UdpMatch&);

  public:
    UdpMatch();
    UdpMatch(const UdpMatch& other);
    virtual ~UdpMatch();
    UdpMatch& operator=(const UdpMatch& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual uint16_t getLength() const;
    virtual void setLength(uint16_t length);
    virtual const PortRange& getSrcPortRange() const;
    virtual PortRange& getSrcPortRangeForUpdate() { return const_cast<PortRange&>(const_cast<UdpMatch*>(this)->getSrcPortRange());}
    virtual void setSrcPortRange(const PortRange& srcPortRange);
    virtual const PortRange& getDestPortRange() const;
    virtual PortRange& getDestPortRangeForUpdate() { return const_cast<PortRange&>(const_cast<UdpMatch*>(this)->getDestPortRange());}
    virtual void setDestPortRange(const PortRange& destPortRange);
};

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:72</tt> by nedtool.
 * <pre>
 * class IcmpMatch
 * {
 *     int8_t type = -1;
 *     int8_t code = -1;
 * }
 * </pre>
 */
class INET_API IcmpMatch
{
  protected:
    int8_t type = -1;
    int8_t code = -1;

  private:
    void copy(const IcmpMatch& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const IcmpMatch&);

  public:
    IcmpMatch();
    IcmpMatch(const IcmpMatch& other);
    virtual ~IcmpMatch();
    IcmpMatch& operator=(const IcmpMatch& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual int8_t getType() const;
    virtual void setType(int8_t type);
    virtual int8_t getCode() const;
    virtual void setCode(int8_t code);
};

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:77</tt> by nedtool.
 * <pre>
 * class Matches
 * {
 *     Ipv4Match ipv4;
 *     Ipv6Match ipv6;
 *     TcpMatch tcp;
 *     UdpMatch udp;
 *     IcmpMatch icmp;
 * }
 * </pre>
 */
class INET_API Matches
{
  protected:
    Ipv4Match ipv4;
    Ipv6Match ipv6;
    TcpMatch tcp;
    UdpMatch udp;
    IcmpMatch icmp;

  private:
    void copy(const Matches& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Matches&);

  public:
    Matches();
    Matches(const Matches& other);
    virtual ~Matches();
    Matches& operator=(const Matches& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual const Ipv4Match& getIpv4() const;
    virtual Ipv4Match& getIpv4ForUpdate() { return const_cast<Ipv4Match&>(const_cast<Matches*>(this)->getIpv4());}
    virtual void setIpv4(const Ipv4Match& ipv4);
    virtual const Ipv6Match& getIpv6() const;
    virtual Ipv6Match& getIpv6ForUpdate() { return const_cast<Ipv6Match&>(const_cast<Matches*>(this)->getIpv6());}
    virtual void setIpv6(const Ipv6Match& ipv6);
    virtual const TcpMatch& getTcp() const;
    virtual TcpMatch& getTcpForUpdate() { return const_cast<TcpMatch&>(const_cast<Matches*>(this)->getTcp());}
    virtual void setTcp(const TcpMatch& tcp);
    virtual const UdpMatch& getUdp() const;
    virtual UdpMatch& getUdpForUpdate() { return const_cast<UdpMatch&>(const_cast<Matches*>(this)->getUdp());}
    virtual void setUdp(const UdpMatch& udp);
    virtual const IcmpMatch& getIcmp() const;
    virtual IcmpMatch& getIcmpForUpdate() { return const_cast<IcmpMatch&>(const_cast<Matches*>(this)->getIcmp());}
    virtual void setIcmp(const IcmpMatch& icmp);
};

/**
 * Enum generated from <tt>inet/_extra/networklayer/FilterRule.msg:85</tt> by nedtool.
 * <pre>
 * enum ForwardingActions
 * {
 *     MATCH = 0;
 *     ACCEPT = 1;
 *     DROP = 2;
 *     RATE_LIMIT = 3;
 * }
 * </pre>
 */
enum ForwardingActions {
    MATCH = 0,
    ACCEPT = 1,
    DROP = 2,
    RATE_LIMIT = 3
};

/**
 * Class generated from <tt>inet/_extra/networklayer/FilterRule.msg:92</tt> by nedtool.
 * <pre>
 * class Action
 * {
 *     ForwardingActions forwarding;
 *     double rateLimit;
 * }
 * </pre>
 */
class INET_API Action
{
  protected:
    inet::ForwardingActions forwarding = static_cast<inet::ForwardingActions>(-1);
    double rateLimit = 0;

  private:
    void copy(const Action& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Action&);

  public:
    Action();
    Action(const Action& other);
    virtual ~Action();
    Action& operator=(const Action& other);
    virtual void parsimPack(omnetpp::cCommBuffer *b) const;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b);

    // field getter/setter methods
    virtual inet::ForwardingActions getForwarding() const;
    virtual void setForwarding(inet::ForwardingActions forwarding);
    virtual double getRateLimit() const;
    virtual void setRateLimit(double rateLimit);
};

} // namespace inet

#endif // ifndef __INET_FILTERRULE_M_H

